### 最小生成树
有两种最小生成树生成算法，Kruskal,Prim

#### Kruskal算法
Kruskal算法是一种基于贪心方法的最小生成树算法。该算法初始将图
视为森林，图中的每一个顶点是一课独立的树。一颗树只与它的邻接
顶点中权值最小且不违反最小生成树属性（不构成环）的树之间建立
连边。

- 将所有的边按照权值进行非降序排序
- 选择权值最小的边
- 判断这条边构不构成环
- 构成环则放弃，下一条边
- 重复步骤二,直到所有顶点都被访问到，则算法停止

如何判断边构不构成环，可以选择[Union-Find/并查集](../../UnionFind/README.md)
的方法。


#### Prim算法
普里姆算法在找最小生成树时，将顶点分为两类，一类是在查找的过程中已经包含在生成树中的顶点（假设为 A 类），剩下的为另一类（假设为 B 类）。

对于给定的连通网，起始状态全部顶点都归为 B 类。在找最小生成树时，选定任意一个顶点作为起始点，并将之从 B 类移至 A 类；然后找出 B 类中到 A 类中的顶点之间权值最小的顶点，将之从 B 类移至 A 类，如此重复，直到 B 类中没有顶点为止。所走过的顶点和边就是该连通图的最小生成树。

**然后找出 B 类中到 A 类中的顶点之间权值最小的顶点**: 这一过程非常关键，我们可以借用cpp中基于红黑树实现
的multimap，key为边的权值，value为边的两个顶点，begin()指针是权值最小的map指针，我们可以判断两个顶点
是不是都在A类中，如果都在，则从map中删除这一项。如果指针的两个顶点都不在A类中，则跳过。如果指针的两个
顶点一个在A类中，一个在B中，则在B中的顶点转移到A中，同时map删除这一项，指针回到begin,进入洗一个循环。

[代码](./Solution.cc)只实现了Prim算法，不过这两个算法是相同的，后面再补充。

[这里](https://mp.weixin.qq.com/s?__biz=MzA4NDE4MzY2MA==&mid=2647520862&idx=1&sn=0bfa987a59d36130b67531eeee63b97e&scene=21#wechat_redirect)有一篇很好的文章，详细介绍了Kruskal和prim算法。可以作为参考
