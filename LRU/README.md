### Least Recently Used (LRU)/最近最少使用
如果一个数据最近被访问过，那么它将来的被访问的概率要高。基于这一个
思想，可以用来解决计算机系统中的表页替换问题和实际业务中的热点数据
问题。

算法实现的思路是利用双链表和2个哈希表来实现热点数据的存放和数据的
快速查询问题。细节是，先来的数据放在链头，后来的数据放在链尾，哈希表
记录节点的位置，节点存放着数据信息。当然这个过程中存在存放空间不够的
问题，需要将最近最少使用的节点删除，然后加入新的节点，这会导致出现存
在多个节点访问次数相同的问题。所以需要另外一个哈希表用来存储相同访问
次数节点中最近被访问的那个。

假如我们提供两个方法get(key)和put(key, value)来进行数据的访问，那么，
在get方法被调用后，如果存在对应为key的节点，那么对应节点的访问次数
应该+1,同时将此节点更新到所访问次数对应的最新位置在链表中。同时，记录
相同访问次数节点的哈希表如果和更新的key节点有相关联系，那么这个哈希表
也需要被更新。具体的更新方法是如果一个节点的访问次数是n,那么存储n次访问
次数的哈希表中的节点如果是当前被更新的节点，那么这个哈希表n对应的节点
要么被置为空或者置为更新节点的前一个节点当且仅当前一个节点的访问次数和
当前节点相同。

说到put操作。如果双链表中存在key节点，那么将该节点的value值更新，访问
次数更新加1，然后将此节点按照get的更新方法进行更新。如果双链表中不存在
key值所对应的节点，将为两种情况。一，存储空间剩余。二，存储空间不剩余。
情况一，将新节点插入表头，更新到对应位置。情况二，将表头节点中的key,value,
访问次数全部替换成新的数据，同时更新两个哈希表对应的数据，然后将表头节点
位置进行相对应的更新。

[代码实现在这里](./LRU.cc)
