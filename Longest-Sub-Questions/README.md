### 最长公共子问题
像最长的子问题我们一般都可以规约到动态规划的处理思路
上来，因为动态规划的本质就是子问题的递归和有条件的
剪枝

#### 最长公共子串
有字符串S1,S2, 让dp[i][j]表示S1以i结尾，S2以j结尾的最长
公共字串长度，如果S1[i]==S2[j]，那么dp[i][j] = dp[i-1][j-1]+1，
否则dp[i][j] = 0。时间复杂度是O(n^2)

#### 最长递增子序列
可以使用动态规划解法，也可以使用二分查找方法。动态规划
的时间复杂度为O(n^2),二分查找为O(nlog(n))

- 动态规划
    假设长度为n的数组A={a_0,a_1,...,a_(n-1)},以a_i结尾的
    最长递增子序列为L_i,那么 当j<i<n且a_i>a_j，L_i=max(L_i, L_j+1)

- 二分查找
    使用一个数组存储在该位置长度最晚出现的最大的数，最后数组的长度
    即最长递增子序列的长度。我们使用一个辅助数组B，end为数组B的某位数
    遍历原始数组中所有的元素x=A[i],如果x大于end，则将x添加到B数组某尾，
    如果x<end，则用二分查找法找到B中第一个大于x的数，并将改数替换成x

#### 最长公共子序列
有两个字符串s1,s2.len(s1)>=len(s2).我们要计算这两
个字符串的最长公共子序列的长度。

使用动态规划的思想，我们使用二位数组dp[i][j]表示
s1[0:i]和s2[0:j]的最长公共子序列长度，那么我们可以
得到
```
if(s1[i] == s2[j]){
    dp[i][j] = max(dp[i][j], dp[i-1][j-1]+1, dp[i-1][j], dp[i][j-1]);
}else{
    dp[i][j] = max(dp[i][j], dp[i-1][j], dp[i][j-1]);
}
```
时间复杂度为O(n^2)

### 最长递增子串
可以使用两个下标来表示它们之间的数是递增的
```
i=0;
j = i+1;
mx = 0;
while(i<n){
    while(j<n and arr[j]>arr[j-1]){
        j += 1;
    }
    //这时候j要么比前一个数小要么超过数组边界
    mx = max(mx, j-i);
    i = j;
    j = i+1;
}
return mx;
}
```
时间复杂度为O(n)
